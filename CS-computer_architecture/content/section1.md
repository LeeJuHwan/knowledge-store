# Chapter 1: 컴퓨터 내부의 언어체계 - 컴퓨터는 어떤 말을 사용할까

---

### 들어가며

> “ 참 안됐네요 ”
>

 스웨덴 교환 학생이 고등학교를 졸업 하면 엔지니어링을 할 것이라고 생각 하고 있고, 이전 프로그래밍 과목을 들었을 때 **자바를** 들었다.

**본능적으로 대답 했다. “ 참 안됐네요 “**

<br>

> 프로그래밍을 제대로 잘 해야 하는 이유
>

컴퓨터 프로그래밍의 영역은 믿을 수 없을 정도로 다양하다. 하지만, 컴퓨터 프로그래밍에서 이상한 점은 의학과 달리 다방면의 지식을 갖추지 않아도 전문가가 될 수 있다는 점이다.

소프트웨어는 일상 생활에 가장 밀접 해 있고 인간이 신뢰 하고 있지만, 의료 사고 처럼 프로그래밍도 소프트웨어 품질에 의한 검증이 불가피 하여 사고를 일으키는 경우가 존재 하고 이로 인해 자신감을 갖을 수 없게 된다.

<br>

> 프로그래밍은 그저 시작이다
>

누구나 코딩을 배우는 시대로 변해 가고 있고, 버락 오바마 미 전대통령 또한 자바스크립트로 간단한 코드를 작성 할 수 있다.

**그렇다면 오바마는 프로그래머인가?**

이 처럼 프로그램을 작성 하는 접근성이 낮아진다는 것은 프로그래머의 쏟아지는 수요로 저평가 되기 쉬운 상황이 발생한다. 그렇다면, 취미반 프로그래머가 아닌 실력 있는 프로그래머가 되려면 그저 프로그램을 작성하는 것에 끝이 아닌, 컴퓨팅 사고를 바탕으로 컴퓨터에게 명확한 명령을 통해 대화 할 수 있어야 하는 것

<br>

> 하부 기술 지식의 중요성
>

하부 기술은 눈에 띄게 체감 할 수 없지만 프로그램의 디버깅 과정에서 에러 트래킹을 할 때 조금 더 나은 선택을 할 수 있게 해준다. 그 것이 선택이 아닌 가설일지라도 조금 더 올바른 방향으로 이끌 수 있다. 그 근간은 하부 기술은 모두 공통적인 요소를 띄고 있기 때문이다.

<br>

> 컴퓨터를 생각 해 본적 있는가?
>

컴퓨터는 명령을 수행하는 기계 일 뿐이다. 그렇기 때문에 이 책을 다 읽고 나면 나는 컴퓨터를 하나의 멍청한 기계라고 생각 할 것이다. 그저 소모품, 그저 내가 시키는 것 만 할 수 있는 바보 정도? **앞으로! 절대! 컴파일링을 위해 행운의 손가락을 꺼내지 않을 것이다 🤞**

<br>

> 컴퓨터 프로그래밍 = 3살 아이와 의사소통 하는 것
>
1. 명령 할 내용을 전반적으로 이해 할 것
2. 이해 한 내용을 3살 짜리 아이에게 설명 해줄 것

내가 가르치는 아이는 밖으로 나가기 위해 신발의 위치를 물어 보면 신발장에 있다고 말한다. 우린 나갈거야 라고 말 해도 신발을 신으라는 말, 문을 열라는 말 이런 과정들은 인간이 자라면서 배우는 유연성과 추론 능력이 없기 때문에 아이는 나가라고 하면 나갈 방법이 없더라도 나가려고 할 것이다.

우리의 컴퓨터도 마찬가지이다. 나는 매일 아침 날씨를 확인 하는 습관이 있는데, 날씨를 확인 하기 위해 웹 브라우저(크롬)을 열면 기본 홈페이지에서 가만히 있는다. 나는 이 컴퓨터에게 어느 웹 사이트에서 어떤 날씨 정보를 불러오라고 말을 하지 않았다.

---

<br>

## 1장 - 컴퓨터 내부의 언어 체계

### 이진수의 덧셈

- 두 비트를 서로 더한 결과는 두 비트를 XOR 한 값과 같다.
- 올림은 두 비트를 AND 한 값과 같다. → carry-bit

**덧셈 결과가 사용 할 비트의 개수로 표현 할 수 있는 범위를 벗어난다면?**

**오버플로**

- MSB에서 올림이 발생함
- 상태코드 레지스터에 오버플로 비트를 저장 하고 있고, 나중에 이 비트값을 통해 오버플로가 발생 했는지 확인이 가능함

**언더플로**

- MSB 위쪽에서 1을 빌려오는 경우
- 오버플로와 마찬가지로 레지스터에 저장 되어 있음

> 음수 표현 법 중: 2의 보수
>

1의 보수, 부호 들은 0을 표현 하는 방법이 두 가지라서 또는 덧셈 연산에서 AND와 XOR을 사용 할 수 없기 때문에 현대적으로 사용 되는 것은 2의 보수 표현법이다.

어떤 수의 비트를 뒤집고 1을 추가 하면 음수를 얻을 수 있다. 이 때, MSB (이하 비트의 크기 중 가장 왼쪽에 위치) 에서 올림이 발생 하면 이 값은 버린다.

10진수 +7 을 음수로 표기하는 과정을 살펴보자

💡 OUT: -7

IN: 0111

- 비트 반전(비트 자리 마다 NOT 연산)

    → 1000

- 반전 된 비트의 1 덧셈 연산

    → 1001 : -7

이렇게 2의 보수 표현법이 가능한 이유는 위 처럼 **0을 표현 하는 방법이 하나 뿐**이다. 그 이유는, 오버플로가 발생 하게 되면 지금까지 상태코드 레지스터에 저장 한다고 했던 것 처럼 올림 비트로 생각 하고 무시한다.

> IEEE 부동소수점 수 표준
>

부동소수점 수 시스템은 컴퓨터에서 계산을 수행 할 때 실수를 표현하는 표준 방법이다. 가수와 지수에 대해 각 각 부호 비트를 사용한다. 다만, 지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져있다. 낭비되는 비트 조합을 최소화 하고 반올림을 쉽게 하기 위한 여러가지 트릭이 사용된다.

- IEEE 754 표준의 트릭
    1. 똑같은 비트를 사용 하더라도 정밀도를 가능한 높이고 싶다.

        → **정규화**를 통해 가수를 조정하여 맨 앞(왼쪽)에 0이 없게 만드는 것, 가수를 조정 하기 위해서 지수도 조정 해야함

    2. 가수의 맨 왼쪽 비트가 1이라는 것을 알고 있기 때문에 생략 하는 것 → 이로 인해 가수에 1비트를 더 사용 할 수 있음

💡 기본 정밀도 부동 소수점 수와 2배 정밀도 부동소수점 수

- 기본 정밀도 수
  - 32비트 사용
  - 10^38 +- 범위 표현 가능
- 2배 정밀도 수
  - 64비트 사용
  - 10^308 +- 범위 표현 가능

![image](https://github.com/LeeJuHwan/knowledge-store/assets/118493627/db8eecba-da28-4129-b7b7-8fa77a174412)

- 두 형태 모두 가수에 대한 부호 사용 → S 문자
- 2배 정밀도 수가 기본 정밀도 수 보다 지수가 3비트 더 크다
  - 따라서, 지수의 범위는 8배가 더 큼 → 2^3 크기를 뜻 함
  - 2배 정밀도 수는 기본 정밀도 수 보다 가수가 29비트가 더 큼
- 부호 비트가 따로 존재 하지 않음
  - 지수 비트가 모두 0이거나 1인 경우 특별한 의미를 갖게 하고, 실제 지숫값은 나머지 비트 패턴에 집어 넣는 설계 방식을 추구하였고, **편향된 지숫값**을 사용 하여 추구하고자 하는 방식을 적용 함
  - 기본 정밀도의 편향값: 127 → 01111111 = 지수 0을 표현 함
    - 127을 더해서 양수인 경우는 맨 앞 비트가 1이고 음수인 경우는 맨 앞 비트가 0이 됨
  - 2배 정밀도 수의 편향값: 126

### 특별한 비트 패턴과 정밀도

IEEE 형식은 특별한 비트 패턴을 하나 더 가지고 있습니다. 지수의 모든 비트가 1일 때 가수가 0이라면, 표현되는 수는 **무한대**입니다. 그리고 가수가 0이 아니라면 그 수는 **Not a Number(NaN)**입니다. 위에서 0을 표현할 때 봤던 표를 다시 가져왔습니다. 아래 표는 IEEE 부동 소수점 형식에 대한 모든 특별한 비트 패턴을 보여줍니다.

![image](https://github.com/LeeJuHwan/knowledge-store/assets/118493627/814c15e6-4e06-4c8a-b03c-a76092aa14f8)

[이해를 도운 블로그 글 출처](https://junstar92.tistory.com/253)

> BCD(Binary-Coded- Decimal)
>

2진 코드화 한 10진수 라는 뜻으로, BCD는 4비트를 사용 하여 10진 숫자 하나를 표현 한다.

- 0001 0010 = 12
  - 띄어쓰기를 통하여 각 자리 수 표기를 나타냄

❗**일반적인 2진수에 비해 같은 수를 표현 할 때 더 많은 비트를 사용 하는 점에서 비트 낭비로 인해 인기가 떨어짐**

### 비트 그룹의 이름

---

| 이름 | 비트 개수 |
| --- | --- |
| 니블(nibble) | 4 |
| 바이트(byte) | 8 |
| 하프 워드(half word) | 16 |
| 워드(word) | 32 |
| 더블 워드(double word) | 64 |

> 워드
>

컴퓨터가 설계 상 **자연스럽게 사용 할 수 있는 비트 묶음의 크기**를 가리키는 말로 쓰이며, 컴퓨터가 **빠르게 처리 할 수 있는 가장 큰 덩어리**를 뜻 함

### 색을 표현 하는 방법

---

**컴퓨터 그래픽스**는 전자 모눈종이에 해당하는 것에 색을 표현하는 점을 찍어서 그림을 만드는 과정이다.

이 때, 모눈의 각 격자에 찍는 점을 **픽셀** 이라고 부른다.

컴퓨터 모니터는 RGB 색 모델을 만들어내며, 컬러큐브 라는 것으로 표현 할 수 있다.

![image](https://github.com/LeeJuHwan/knowledge-store/assets/118493627/4c478f97-b361-4277-b4f7-c0c2a033b252)

<aside>
💡 컬러큐브에서 각 축은 주 색을 표현 하며, 값이 0이면 그 에 해당 하는 주 색의 빛을 끄고, 1이면 최대 밝기로 켜는 것이다.

색상을 섞어 다른 색을 나타내는 혼합 색 표현 방식을 가산 색 시스템이라고 부른다.

- 컴퓨터가 아닌 손으로 그림을 그린다면 감산 색 시스템에 더 익숙하다.

</aside>

**컴퓨터가 표현하는 색상**

현대 컴퓨터들은 색을 표현 하는 데 24비트를 사용 해 1천만에 가까운 2의 제곱수에 해당 하는 색을 표현 할 수 있는데, 이 24비트는 세 가지 8비트 필드로 나뉘며 각 필드는 세 가지 주요 색을 표현한다.

![image](https://github.com/LeeJuHwan/knowledge-store/assets/118493627/4518ccea-234b-45d5-abcb-aa2e3be1d511)

- 24비트에 해당 하는 미사용인 이유는 현대 컴퓨터들이 24비트 단위로 계산을 수행 하도록 설계 되지 않았기 때문
  - 24비트에 가장 가까운 표준 크기인 32비트(워드)에 색을 넣어서 처리함.
- 하지만, 이렇게 낭비 되는 비트를 고대 컴퓨터인들은 지나칠 수 없었기 때문에, 이 부분을 **투명도에 사용**

> 투명도
>

투명도는 위에 그림에 보이는 미사용 부분을 사용하고, 1 ~ 255까지의 값을 a 라는 값으로 사용한다.

RGB 색상을 그대로 저장 하는 대신, 각각의 색 값에 a를 곱한 값을 투명도에 저장한다.

R: 200, G: 0, B: 0 의 투명도

<aside>
💡 a(투명도) = 0.5

- R: 200 * 0.5 = 100
  - R:100, G:0, B:0
- a: 255 * 0.5 = 127
  - A:127

→ RGBA: 100, 0, 0, 127

1. 이미지 합성은 색값을 a로 곱하는 과정을 통해 이루어짐.
2. 미리 곱한 값을 저장하는 방법을 이용 하여 픽셀을 사용 할 때 마다 a를 곱하는 계산을 반복 할 필요가 없음

</aside>
